import re
import socket
import struct
import optparse
from collections import Counter 

def main():
    usage = "usage: %prog [options] [Input, Output]"
    param = optparse.OptionParser(usage=usage)
    param.add_option('-f', '--features', action="store", type="int", dest="features", default="1",
                     help="1: Only detect and extract IP addr from input file.\t2: Sort each line with its IP addr [default: %default]")
    param.add_option('-d', '--distinct', action="store_true",
                     dest="distinct", default=False, help="Remove duplicate IP [default: %default]")
    param.add_option('-c', '--count', action="store", type="int", dest="count", default="-1",
                     help="Remove and count duplicate IP\t\t\t\t1: Sorted by IP\t\t\t\t\t\t\t2: Sorted by repeat count [default: %default]")
    (options, args) = param.parse_args()
    if len(args) < 2:
        print("[*] (default)Input: ip.txt, Output: sorted_ip.txt")
        args = ["ip.txt", "sorted_ip.txt"]
    with open(args[0]) as f:
        # s=f.read()
        # l=re.findall(r'(?<![\.\d])(?:\d{1,3}\.){3}\d{1,3}(?![\.\d])', s)
        # print(l)
        # ll=list(set(l))
        # # ll.sort(lambda x,y: cmp(''.join( [ i.rjust(3, '0') for i in x.split('.')] ), ''.join( [ i.rjust(3, '0') for i in y.split('.')] ) ) )
        # # print(ll)

        data = {}
        data_2 = {}
        count = 0
        for line in f.readlines():
            # print(line)
            data_2 = {}
            key_int = ""
            l = re.findall(
                r'(?<![\.\d])(?:\d{1,3}\.){3}\d{1,3}(?![\.\d])', line)
            # print(l)
            if len(l) > 0:
                for key in l:
                    key_int = str(struct.unpack(
                        '>I', socket.inet_aton(key))[0])

                    data_2[key_int] = line.replace("\n", "")
                    data[str(count)] = data_2
            count += 1
        # print(data)

        data_s = sorted(data.items(), key=lambda x: int(
            list(x[1].keys())[0].split(",")[0]))
        # print(data_s)

        with open(args[1], 'w+') as f2:

            if options.features == 2:
                if options.distinct == 1:
                    print("[*] `-d` Only available on feature 1")
                print("")
                for sorted_data in data_s:

                    line = list(sorted_data[1].values())[0]
                    print(line)
                    f2.write(line + '\n')

            elif options.features == 1:
                print("")

            if options.count == -1:
                if options.distinct != 1:
                    for sorted_data in data_s:
                        for key in list(sorted_data[1].keys()):
                            line = socket.inet_ntoa(
                                struct.pack('>I', int(key)))
                            print(line)
                            # print(sorted_data[1])
                            f2.write(line + '\n')
                else:
                    lines = []
                    for sorted_data in data_s:
                        for key in list(sorted_data[1].keys()):
                            line = socket.inet_ntoa(
                                struct.pack('>I', int(key)))
                            if line not in lines:
                                lines.append(line)
                                print(line)
                                f2.write(line + '\n')

            else:
                lines = []
                for sorted_data in data_s:
                    for key in list(sorted_data[1].keys()):
                        line = socket.inet_ntoa(
                            struct.pack('>I', int(key)))
                        # print(line)
                        lines.append(line)
                count_dict=dict(Counter(lines))
                if options.count ==1:
                    count_dict=sorted(count_dict.items(),key=lambda x:struct.unpack(
                    '>I', socket.inet_aton(x[0]))[0])
                if options.count ==2:
                    count_dict=sorted(count_dict.items(),key=lambda x:x[1])
                for ip,count in count_dict:
                    print(ip+f'\t[{count}]')
                # print(sorted_data[1])
                    f2.write(ip+f'\t[{count}]\n')
if __name__ == "__main__":
    main()
